########################## README ##############################
#
#   This project has been done as a part of EECS584, 2013 
#   Project participants:
#       - Garrett Hamers (gchamers)
#       - Pankhuri Gupta (pankhuri)
#   
#   Instructor: Professor Barzan Mozafari
#
################################################################

## NOTE :
    We have made some changes in to the blinkDb folder
    
############################################################################
#                            FIRST SECTION                                 #
############################################################################
# Command Line Arguments:

# For scriptInit.sh
1. Base : base working directory
2. totalFrames: total number of frames
3. totalDistances: toal number of distances

# For scriptMiddle.sh
1. Frame Number : The current Frame number for which we are running our experiment
2. Old Frame Number : The previous frame number 
    (this is used for generating queries to Drop the already existing candidates in DB)
3. DistanceFraction : The fraction with which we want our query types to differ 
                      between two consecutive time frames.
4. Base: This is the base path where you have all the code placed. 
         The intermediate files will be generated with respect to this base location


# Current Values
1. Frame Numbers (0-10)
2. Distance Fraction :  0 = 10%
                        1 = 30%
                        2 = 50%
                        3 = 70%
                        4 = 90%

3. basepath = "/home/ec2-user/eecs584"
Note: Location of blinkDB directory will be parallel to the eecs584 folder:
eg:   
    eecs584/../  ==>  is also the directory for blinkdb

# Running the code
1. Go to the main directory
2. sh scriptInit.sh "/home/ec2-user/eecs584" 10 5
3. sh scriptMiddle.sh 2 1 0 "/home/ec2-user/eecs584"

# Thes scripts automatically take care of running the entire pipeline for the mentioned 
# frame and distance Fraction.
# The explanation of each and every part is given in the next section


############################################################################
#                         SECOND SECTION                                   #
############################################################################


1. Generating initial sample candidates (queries for sample creation) 
    java : eecs584/code/SimpleWorkLoadGenerator
    args :  "-samples" 0    
        0 represents the time frame (starting)

2. Generating query workload (for different time frames and different distance fractions)  
    java : eecs584/code/SimpleWorkLoadGenerator
    args : -queries

3. Running these queries in the database (to generate the candidateS)
    python script : eecs584/python/candidateQueriesRunner.py
    args :  0            // frame number 
            "create"     // the same script is for running the CREATE/DROP queries and StatsCollector queries for the candidates
            "no"         // Whether we have to run the drop queries for the previous frames candidates or not.
                        // In case the frame number is 0, there won't be any candidates in database, hence no need to runthe DROP queries

4. Run the queries on the database with all the samples already built in blinkDB
    All the queries generated by the java code are present in :
                ${base}/workloadGen/querySet/querySet${dist}/frame_${frame}/workload.queries 
    output location for the results obtained after runnning in blinkdb:
                ${base}/workloadGen/querySet/querySetOutput${dist}/frame_${frame}/workload_all.result
    command for running:
    ./bin/blinkdb -i ${base}/workloadGen/querySet/querySet${dist}/frame_${frame}/workload.queries > ${base}/workloadGen/querySetOutput/querySet${dist}/frame_${frame}/workload_all.result ;


5. Run queries for collecting statistics of the query seta and candidates:
    python candidateQueriesRunner.py 0 "stats"
    python workloadQueriesRunner.py ${oldFrame} ${dist}

    cd ${base}"/python"
    python parser.py ${oldFrame} ${dist}


####################################################################################################################
                                CODE IMPLEMENTATIONS and EXPLANATIONS: 
####################################################################################################################

##########################################################
JAVA code : for workload generation
##########################################################
1. Java : SIMPLE WORKLOAD GENERATOR
    Location : eecs584/code/src/workload/SimpleWorkloadGenerator.java

    Functions
        a) Generates candidates for the mentioned time frame
        b) Generates query workload for all frams and all distance fractions in one go

2. Sample Candidates Generator
    Location :  eecs584/code/src/sampleCandidates/
    i) SampleQueryGenerator.java
    Functions:  
        a) Generates Create, Drop queries for candidates
        b) Queries for Stats collection of candidates;
            - Dqcs : queries are of the form SELECT COUNT(*) FROM (SELECT 1 FROM <sampletablename> GROUP BY <qcs list>)
            - Storage : queries of the form SELECT COUNT(*) FROM <sampleTableName>

    ii) SampleGenerator.java
        Calls appropriate functions in the above mentioned class and writed the outputs and queries generated to output files in location :  eecs584/workloadGen/candidateSet/frame_${frameNo}/

3. Query:
    Location : eecs584/code/src/query
    i) Query,java   : Design class for queries
    ii) QueryBuildertools.java
    iii) Query generator.java
            - QueryGeneratorRandomType()    : This generates a new type of query (characterised by a new type of Qcs)
            - GenerateSqlInstanceSameQuery()    : For a query type (a qcs), this generates the SQL instance. This iwll have different constants for the where clause predicates.

4. frame
    i) Frame.java       : design class for a time frame
    ii) FrameGenerator.java
        - GenerateNewTimeFrame() : This will generate a completely new time frame.
                                    Such a frame will have a set of different query types
                                    Each query type wil have a set of SQL instances differening in the constant conditions in where clause predicates
                                    The number of sql instances generated for each query type in a frame is generated using a Power law distribution
5. distributions:
    i) GenerateDistribution.java    : Generates a power law, gaussian or uniform distribution


##########################################################
Python code :
##########################################################
Location : eecs584/python

1) parser.py
        This is used to parse the output produced from running the queries into blink db in a form that can be accepted by glpk solver

2. glpkparser.py
        This accepts the output from the glpk solver
        output : writes the qcs that should be generated in the next time frame as an output file at : eecs584/modelGen/glpk_output

3. queryProb.py
        Accepts the frequencies of the query qcs and outputs probabilities.
        This is used as an input by the glpk solver

Location : blinkdb/
1) candidateQueriesRunner.py
        This runs the create, drop, dqcs collector and storage collector querieds for the candidates depending upon the arguments passed to it

2) workloadQueriesRunner.py
        This runs the dqcs and sparsity collector queries for the incoming query workload.


##########################################################
GLPK code :
##########################################################
Location : eecs584/modelGen/ModelGenerator.java

This accepts the input files from location : eecs584/GLPK_Files/input/
And geneates:
    i) Model file
    ii) data file
for the glpk solver

####################################################################################################################
####################################################################################################################
